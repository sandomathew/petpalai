from django.db import models
from django.contrib.auth import get_user_model # To get the User model
from django.utils import timezone # For default datetime values

# Get the custom user model if defined, or Django's default User model
# This makes the model flexible to use with custom user models later.
User = get_user_model()

class FoodLabelScan(models.Model):
    """
    Represents a single scan of a pet food label, storing the image,
    extracted text, parsed nutritional data, and AI-generated analysis.
    """
    # User Association (for future scalability)
    # Allows linking a scan to a specific user. Nullable for MVP or anonymous scans.
    user = models.ForeignKey(
        User,
        on_delete=models.SET_NULL, # If the user is deleted, don't delete their scans
        null=True,                  # Allows the field to be NULL in the database
        blank=True,                 # Allows the field to be blank in forms
        related_name='food_label_scans', # Reverse relation name from User to FoodLabelScan
        help_text="The user who uploaded this food label scan (optional)."
    )
    PET_TYPE_CHOICES = [
        ('dog', 'Dog'),
        ('cat', 'Cat'),
        ('fish', 'Fish'),
        ('bird', 'Bird'),
        ('Snake, Lizards', 'Reptile' ),
        ('other', 'Other Pet Food'),
    ]
    pet_type = models.CharField(
        max_length=20,  # Max length for the choice key
        choices=PET_TYPE_CHOICES,  # Use the defined choices
        default='OTHER',  # Default value if not specified
        help_text="The type of pet type (e.g., Dog, Cat, Bird)."
    )
    # Original Image File
    # Stores the uploaded image file. Images will be saved in MEDIA_ROOT/pet_food_labels/
    image = models.ImageField(
        upload_to='pet_food_labels/',
        help_text="The uploaded image file of the pet food label."
    )

    # Raw Text Extracted by OCR
    # Stores all the text that Tesseract OCR manages to pull from the image.
    raw_text = models.TextField(
        blank=True, # Allow this field to be empty if OCR fails or finds no text
        help_text="Raw text extracted from the image by the OCR engine."
    )
    # --- FIELDS FOR CALORIE CONTENT ---
    calorie_content_kcal_per_kg = models.DecimalField(
        max_digits=8,  # e.g., 9999.9999
        decimal_places=2,  # Store two decimal places
        blank=True,
        null=True,
        help_text="Metabolizable Energy (ME) in kilocalories per kilogram (kcal ME/kg)."
    )
    calorie_content_per_unit = models.CharField(
        max_length=100,
        blank=True,
        null=True,
        help_text="Calorie content per familiar unit (e.g., '67 kcal ME/can', '450 kcal per cup')."
    )

    # Parsed Nutritional Data (Flexible JSON Format)
    # This is where the structured data (calories, protein, ingredients, etc.) is stored.
    # JSONField allows for a flexible schema, perfect for varying label data.
    # It defaults to an empty dictionary.
    parsed_data = models.JSONField(
        default=dict, # Default value for new instances
        help_text="Parsed nutritional data and ingredients in flexible JSON format. "
                  "E.g., {'calories_per_100g': 350, 'protein_percent': 30, 'ingredients': 'Chicken, Rice, etc.'}."
    )

    # AI-Generated Analysis
    # Stores the pros and cons summary generated by the Large Language Model.
    ai_analysis = models.TextField(
        blank=True, # Allow empty if AI analysis fails or is not generated
        help_text="AI-generated pros and cons summary of the pet food, based on parsed data."
    )

    # Product Name (User-provided or Extracted)
    # A human-readable name for the product, helpful for identification.
    product_name = models.CharField(
        max_length=255, # Max length for the name
        blank=True,     # Allow empty if not provided or extracted
        help_text="User-provided or AI-extracted name of the pet food product."
    )

    # Food Type (Categorization)
    # Allows classifying the food (e.g., dry, wet, treat) using predefined choices.
    FOOD_TYPE_CHOICES = [
        ('DRY', 'Dry Food'),
        ('WET', 'Wet Food (Canned/Pouch)'),
        ('TREAT', 'Treat/Snack'),
        ('SUPPLEMENT', 'Supplement'),
        ('OTHER', 'Other'),
    ]
    food_type = models.CharField(
        max_length=20,          # Max length for the choice key
        choices=FOOD_TYPE_CHOICES, # Use the defined choices
        default='OTHER',        # Default value if not specified
        help_text="The type of pet food product (e.g., Dry, Wet, Treat)."
    )

    # Timestamp of Scan
    # Automatically records when the label was uploaded/scanned.
    scanned_at = models.DateTimeField(
        default=timezone.now, # Sets the current time when the object is first created
        help_text="The date and time when the label was scanned."
    )

    # Readable string representation of the object
    def __str__(self):
        user_info = self.user.username if self.user else "Anonymous"
        product_display = self.product_name if self.product_name else "Unknown Product"
        return f"Scan: {product_display} ({self.get_food_type_display()}) by {user_info} at {self.scanned_at.strftime('%Y-%m-%d %H:%M')}"

    # Meta options for the model
    class Meta:
        verbose_name = "Food Label Scan"
        verbose_name_plural = "Food Label Scans"
        ordering = ['-scanned_at'] # Default ordering: most recent first